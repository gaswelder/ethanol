const net = require("net");
const Web3 = require("web3");
const User = require("./user");
const Mnemonic = require("./keys/mnemonic");
const DeployedContract = require("./deployed-contract");
const providers = require("./providers");

class Blockchain {
	constructor(url) {
		this.url = url;
	}

	/**
	 * Returns a default, unspecified user for the blockchain.
	 * Might be useeful to make calls that don't require ether.
	 *
	 * @returns {Promise<User>}
	 */
	async user() {
		throw new Error("hmm");
	}

	/**
	 * Constructs an object representing a blockchain user
	 * from the given mnemonic.
	 *
	 * @param {string} mnemonic
	 * @param {number} index Index in the key series generated by the mnemonic
	 *
	 * @returns {Promise<User>}
	 */
	async userFromMnemonic(mnemonic, index = 0) {
		throw new Error("hmm");
	}

	contract(abi, address) {
		return new DeployedContract(abi, address, this);
	}

	/**
	 * Returns a blockchain object for the given RPC URL.
	 *
	 * @param {string} url RPC URL; may start with "ipc://" or "https://".
	 * @returns {Blockchain}
	 */
	static at(url) {
		if (url.startsWith("ipc://")) {
			return new LocalBlockchain(url);
		}
		if (url.startsWith("https://") || url.startsWith("http://")) {
			return new RemoteBlockchain(url);
		}
		throw new Error("unrecognized url: " + url);
	}

	/**
	 * Returns balance of the given address in Wei.
	 *
	 * @param {string} addr Wallet address
	 * @returns {Promise<BigNumber>}
	 */
	balanceOf(addr) {
		const web3 = this.web3();
		return new Promise((ok, fail) => {
			web3.eth.getBalance(addr, function(err, bal) {
				if (err) return fail(err);
				ok(bal);
			});
		});
	}

	/**
	 * Returns current block number.
	 *
	 * @returns {Promise<Number>}
	 */
	blockNumber() {
		const web3 = this.web3();
		return new Promise(function(ok, fail) {
			web3.eth.getBlockNumber(function(err, val) {
				if (err) return fail(err);
				ok(val);
			});
		});
	}

	/**
	 * Returns a block with the given number.
	 *
	 * @param {Number} blockNumber
	 * @returns {Promise<object>}
	 */
	block(blockNumber) {
		const web3 = this.web3();
		return new Promise(function(ok, fail) {
			web3.eth.getBlock(blockNumber, true, function(err, block) {
				if (err) return fail(err);
				ok(block);
			});
		});
	}
}

class RemoteBlockchain extends Blockchain {
	web3() {
		const p = providers.makeProvider(providers.httpSender(this.url));
		return new Web3(p);
	}

	async userFromMnemonic(mnemonic, index = 0) {
		const m = new Mnemonic(mnemonic);
		const key = m.deriveKey(index);
		const addr = key.address();

		const p = providers.makeProvider(providers.httpSender(this.url));
		const sp = providers.signify(p, key);
		const web3 = new Web3(sp);

		return new User(web3, addr, this);
	}

	async user() {
		return this.userFromMnemonic(
			"science truck gospel alone trust effort scorpion laundry habit champion magic uncover"
		);
	}
}

class LocalBlockchain extends Blockchain {
	web3() {
		const path = this.url.substr("ipc://".length);
		const provider = new Web3.providers.IpcProvider(path, net);
		const web3 = new Web3(provider);
		return web3;
	}

	async userFromMnemonic(mnemonic, index) {
		// web3.eth.accounts.privateKeyToAccount(privateKey) seems to work incorrectly.
		throw new Error("not implemented");
	}

	user() {
		return new Promise((resolve, fail) => {
			const path = this.url.substr("ipc://".length);
			const provider = new Web3.providers.IpcProvider(path, net);
			const web3 = new Web3(provider);
			web3.eth.getAccounts((err, addrs) => {
				if (err) return fail(err);
				resolve(new User(web3, addrs[0], this));
			});
		});
	}
}

module.exports = Blockchain;
